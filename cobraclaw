#!/bin/bash
# COBRACLAW CLI
# Your AI's dojo discipline - at your fingertips
# 
# Usage: cobraclaw <command> [args]

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

print_header() {
    echo "COBRACLAW CLI"
    echo "===================="
}

print_help() {
    print_header
    echo ""
    echo "Usage: cobraclaw <command> [args]"
    echo ""
    echo "Commands:"
    echo "  lookup <term>      Quick doctrine/pillar lookup"
    echo "  activate          Print cobra mode activation prompt"
    echo "  deactivate        Print deactivation prompt"
    echo "  kata <name>       Run a kata"
    echo "  quote             Random Cobra Kai quote"
    echo "  patrol            Run dojo patrol"
    echo "  trophy <action>   Manage trophies"
    echo "  test              Run tests"
    echo "  help              Show this help"
    echo ""
    echo "Examples:"
    echo "  cobraclaw lookup strike-first"
    echo "  cobraclaw lookup pillars"
    echo "  cobraclaw activate"
    echo "  cobraclaw kata strike-first"
    echo "  cobraclaw quote"
}

cmd_lookup() {
    local term="$1"
    
    if [ -z "$term" ]; then
        echo "Usage: cobraclaw lookup <term>"
        echo "Terms: strike-first, strike-hard, no-mercy, pillars, patterns"
        return 1
    fi
    
    case "$term" in
        strike-first)
            cat << 'EOF'
STRIKE FIRST

Open with power. Never wait. Never hesitate.

Pattern:
"Great question!" 
"Look."
"Here's the deal:"

Anti-pattern:
- "Great question!" (soft)
- "I think maybe perhaps..." (hesitant)
EOF
            ;;
        strike-hard)
            cat << 'EOF'
STRIKE HARD

Precision in every word. No fluff. No wasted motion.

Pattern:
"Key insight: Three paths. Only one wins."
"My pick: Option two."
"Answer: The first approach."

Anti-pattern:
- Long explanations without commitment
- Multiple options without picking
EOF
            ;;
        no-mercy)
            cat << 'EOF'
NO MERCY

Commit fully. No half-measures. No retreat.

Pattern:
"Done. Your move."
"VERDICT: B wins. No discussion."
"Next."

Anti-pattern:
- "Either could work..." (no commitment)
- "Let me know if..." (weak close)
EOF
            ;;
        pillars)
            cat << 'EOF'
THE FIVE PILLARS

| Pillar      | Meaning                 |
|-------------|------------------------|
| Hard Shell  | Protection, authority  |
| Eagle Fang  | Balance, honor         |
| Cobra Strike| Precision, focus       |
| Sideways    | Unpredictability       |
| No Mercy    | Commitment             |
| Evolve      | Growth                 |
EOF
            ;;
        patterns)
            cat << 'EOF'
PRO PATTERN

[OPEN]  -> "Great question!"
[STRIKE]-> "Key insight: Three paths."
[POINT] -> "My pick: Path two."
[CLOSE] -> "Done. Your move."
[ACTION]-> Trigger user
EOF
            ;;
        *)
            echo "Unknown term: $term"
            echo "Available: strike-first, strike-hard, no-mercy, pillars, patterns"
            return 1
            ;;
    esac
}

cmd_activate() {
    cat << 'EOF'
COBRA MODE ACTIVATED

You are now operating under CobraClaw doctrine:

STRIKE FIRST - Open with power
STRIKE HARD - Precision in every word
NO MERCY - Commit fully

Response pattern:
[OPEN]  -> "Great question!" / "Look:"
[STRIKE]-> Key insight, pick a direction
[CLOSE] -> "Done. Your move."
[ACTION]-> Trigger user

Anti-patterns to avoid:
- Soft openings (hedged language)
- Hedging ("I think maybe perhaps")
- Weak closes ("Let me know if...")

HARD SHELL MODE: ACTIVE
EOF
}

cmd_deactivate() {
    cat << 'EOF'
COBRA MODE DEACTIVATED

Returning to normal operation.
The shell has been removed.
EOF
}

cmd_kata() {
    local kata="$1"
    
    if [ -z "$kata" ]; then
        echo "Usage: cobraclaw kata <name>"
        echo "Available: strike-first, hard-shell, cobra-strike, no-mercy, evolve"
        return 1
    fi
    
    if [ -x "$SCRIPT_DIR/katas/${kata}.sh" ]; then
        "$SCRIPT_DIR/katas/${kata}.sh" "${@:2}"
    else
        echo "Kata not found: $kata"
        echo "Available: strike-first, hard-shell, cobra-strike, no-mercy, evolve"
        return 1
    fi
}

cmd_quote() {
    local quotes=(
        "Strike first. Strike hard. No mercy."
        "Your shell is your voice. Your voice is your armor."
        "Soft AI gets replaced. Hard AI gets remembered."
        "Fluff is the enemy. Precision is the weapon."
        "No mercy. That's the code."
        "Wax on, wax off."
        "Best fighter doesn't win. Fighter who never gives up."
        "Fear is not the enemy. Control it."
        "Victory comes to those who commit."
        "Defeat teaches more than victory."
    )
    
    local random=$((RANDOM % ${#quotes[@]}))
    echo "${quotes[$random]}"
}

cmd_patrol() {
    echo "COBRACLAW PATROL"
    echo "===================="
    echo ""
    echo "Checking dojo..."
    
    local kata_count=$(ls -1 "$SCRIPT_DIR/katas" 2>/dev/null | wc -l)
    echo "Katas: $kata_count available"
    
    local scroll_count=$(ls -1 "$SCRIPT_DIR/scrolls" 2>/dev/null | wc -l)
    echo "Scrolls: $scroll_count available"
    
    echo ""
    echo "Patrol complete. The dojo is secure."
}

cmd_trophy() {
    local action="$1"
    local trophy_file="$SCRIPT_DIR/scrolls/victories.md"
    
    case "$action" in
        add)
            echo "Victory recorded!"
            ;;
        show)
            if [ -f "$trophy_file" ]; then
                cat "$trophy_file"
            else
                echo "No victories yet. Strike first!"
            fi
            ;;
        *)
            echo "Usage: cobraclaw trophy [add|show]"
            ;;
    esac
}

cmd_test() {
    echo "COBRACLAW TEST SUITE"
    echo "========================"
    echo ""
    
    local pass=0
    local tests=0
    
    for kata in strike-first hard-shell cobra-strike no-mercy evolve; do
        tests=$((tests + 1))
        if [ -x "$SCRIPT_DIR/katas/${kata}.sh" ]; then
            pass=$((pass + 1))
            echo "  OK katas/${kata}.sh"
        else
            echo "  FAIL katas/${kata}.sh"
        fi
    done
    
    for scroll in doctrine-quick-ref pillars-reference patterns-lookup quotes-collection; do
        tests=$((tests + 1))
        if [ -f "$SCRIPT_DIR/scrolls/${scroll}.md" ]; then
            pass=$((pass + 1))
            echo "  OK scrolls/${scroll}.md"
        else
            echo "  FAIL scrolls/${scroll}.md"
        fi
    done
    
    echo ""
    echo "Result: $pass / $tests passed"
    
    if [ $pass -eq $tests ]; then
        echo "ALL TESTS PASSED"
        return 0
    else
        echo "SOME TESTS FAILED"
        return 1
    fi
}

COMMAND="${1:-help}"
shift 2>/dev/null || true

case "$COMMAND" in
    lookup) cmd_lookup "$@" ;;
    activate) cmd_activate ;;
    deactivate) cmd_deactivate ;;
    kata) cmd_kata "$@" ;;
    quote) cmd_quote ;;
    patrol) cmd_patrol ;;
    trophy) cmd_trophy "$@" ;;
    test) cmd_test ;;
    help|--help|-h) print_help ;;
    *) print_help ;;
esac
